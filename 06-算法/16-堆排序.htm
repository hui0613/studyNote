<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>堆排序</title>
</head>

<body>
    <!-- 创建一个大顶堆，大顶堆的堆顶一定是最大的元素
        堆可以看成二叉树
        时间复杂度：O(nlogn)
        空间复杂度 ：O(1)
        不稳定
     -->
    <script>
        function heapSort(arr) {
            createHeap(arr)
            /*
            执行完上述语句之后，数组的排序为从大到小，进行循环得到从小到达的数组
            */
            for (let i = arr.length - 1; i > 0; i--) {
                [arr[i], arr[0]] = [arr[0], arr[i]]
                adjust(arr, 0, i)
            }
            return arr
        }


        /*
        创建一个大顶堆，从最后一个非叶子节点开始，进行下沉操作
        */
        function createHeap(arr) {
            const length = arr.length;
            /*
            将数组排列成二叉树会发现，start 的值正好是 最后一个非叶子节点
            从这里开始调整，将该结点和他的左右孩子进行比计较，将三者中最大的放置根结点
            反复如此
            */
            const start = parseInt(length / 2) - 1;
            for (let i = start; i >= 0; i--) {
                adjust(arr, i, length)
            }
        }
        function adjust(arr, target, length) {
            /*
            由二叉树左右孩子节点和父节点个索引关系可以得出循环的条件
            左孩子索引 = 父节点索引 * 2 
            右孩子索引 = 父节点索引 * 2 + 1
            */
            for (let i = 2 * target + 1; i < length; i = 2 * i + 1) {
                /*
                先比较左右孩子的大小，选出最大的孩子节点，在将大的孩子节点根父节点比较
                */
                if (i + 1 < length && arr[i + 1] > arr[i]) {
                    i = i + 1;
                }

                /*孩子节点大的比副节点大时，进行交换，得到大顶堆，否则表示已经时大顶堆了
                退循环
                */
                if (arr[i] > arr[target]) {
                    [arr[i], arr[target]] = [arr[target], arr[i]]
                    target = i
                } else {
                    break;
                }
            }
        }

        let arr = [124, 3, 5, 2, 8, 2]
        alert(heapSort(arr))
    </script>
</body>

</html>