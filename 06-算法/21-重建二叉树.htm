<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>重建二叉树</title>
</head>

<body>
    <!-- 根据先序遍历和中序遍历的结果重建二叉树 
        更具先序遍历和中序遍历的特点：
        1.由先序遍历的根结点
        2.有根节点后在中序遍历中计算出左右子树的长度
        3.截取左右子树的前序遍历
        4.递归重建二叉树
    -->
    <script>
        function Node(data, left, right) {
            // 二叉树的基本结构
            this.data = data;
            this.left = left;
            this.right = right;
        }

        function reCreateBinarytTree(pre, vin) {
            if (pre.length == 0) {
                return null;
            }
            if (pre.length == 1) {
                return new Node(pre[0]);
            }

            //获取根结点
            const value = pre[0];
            // console.log(value)
            //得到中序遍历中根结点的位置
            const index = vin.indexOf(value);
            //从中序遍历中获取左右子树的字符串结果
            const vinLeft = vin.slice(0, index);
            const vinRight = vin.slice(index + 1);
            console.log(vinRight)
            //从前序遍历中得到左右子树的字符串结果
            const preLeft = pre.slice(1, index + 1);
            const preRight = pre.slice(index + 1)
            const node = new Node(value, null, null);
            node.left = reCreateBinarytTree(preLeft, vinLeft);
            node.right = reCreateBinarytTree(preRight, vinRight);
            // console.log(node)
            return node;
        }
        let pre = "03286"
        let vin = "02368"
        console.log(reCreateBinarytTree(pre, vin))
    </script>
</body>

</html>