# 图

> 图由边的集合及顶点的集合组成。如果一个图的顶点对是有序的，则可以称之为有向图。

## 图的实现

### 图的顶点

```javascript
/**
 * 创建顶点类
 */
function Vertex(label) {
  // 标识节点
  this.label = label;
}
```

### 图的边

图的实际信息都保存在边上，因为边描述了图的结构

#### 邻接表

> 这种方法将所有与节点 n 相连的节点存储在数组索引为 n 处

```javascript
/**
 * 创建顶点类
 */
function Vertex(label) {
  // 标识节点
  this.label = label;
}

function Graph(v) {
  // 存储顶点的个数
  this.vertices = v;
  this.edges = 0;
  // 邻接表
  this.adj = [];
  for (let i = 0; i < this.vertices; i++) {
    this.adj[i] = [];
  }
  this.addEdge = addEdge;
  this.toString = toString;
  this.showGraph = showGraph;

  /**
   * 添加边
   *
   * 传入边所链接的两个顶点
   * @param {*} v
   * @param {*} w
   */
  function addEdge(v, w) {
    this.adj[v].push(w);
    this.adj[w].push(v);
    this.edges++;
  }

  /**
   * 显示图
   */
  function showGraph() {
    for (let i = 0; i < this.vertices; i++) {
      console.log(i + " -> " + this.adj[i]);
    }
  }
}
```

## 搜索图

### 深度优先搜索

> 深度优先搜索包括从一条路径的起始顶点开始追溯，直到到达最后一个顶点，然后回溯，继续追溯下一条路径，直到到达最后的顶点，如此往复，直到没有路径为止。

在构造函数中添加一个新的数组来标志顶点是否被访问过

```javascript
this.mask = new Array(this.vertices).fill(false);
```

dfs 算法

```javascript
/**
 *
 * @param {*} v  开始搜索的顶点
 */
function dfs(v) {
  this.mask[v] = true;
  if (this.adj[v] != undefined) {
    //访问到一个点，作相应的操作
    console.log(v);
  }
  for (let v in this.adj[v]) {
    if (!this.mask[w]) {
      this.dfs(w);
    }
  }
}
```

### 广度优先搜索

> 广度优先搜索算法使用抽象队列来对已访问过的节点进行排序

- 查找与当前节点相连的未访问的节点，并将其添加到以访问的列表队列中
- 从图中取出下一个节点 v，添加到已访问的顶点列表
- 将所有与 v 相连的未访问的节点添加到队列中

```javascript
function bfs(s) {
  let queue = [];
  this.mask[s] = true;
  // 以访问的节点添加到队列中
  queue.push(s);
  while (queue.length > 0) {
    let v = queue.shift();
    if (v != undefined) {
      //进行相应的操作
      console.log("v: " + v);
    }

    for (let i = 0; i < this.adj[v].length; i++) {
      if (!this.mask[this.adj[v][i]]) {
        this.mask[this.adj[v][i]] = true;
        queue.push(this.adj[v][i]);
      }
    }
    // console.log(queue)
  }
}
```

## 广度优先搜索对应的最短路径

要查找最短路径，在广度优先搜索中需要使用一个数组来记录从一个顶点到另一个顶点的路径

在 Graph 路径中添加

```javascript
this.edgeTo = [];
```

新的 `bfs` 方法

```javascript
function bfs(s) {
  let queue = [];
  this.mask[s] = true;
  // 以访问的节点添加到队列中
  queue.push(s);
  while (queue.length > 0) {
    let v = queue.shift();
    if (v != undefined) {
      //进行相应的操作
      console.log("v: " + v);
    }

    for (let i = 0; i < this.adj[v].length; i++) {
      if (!this.mask[this.adj[v][i]]) {
        this.edgeTo[this.adj[v][i]] = v;
        this.mask[this.adj[v][i]] = true;
        queue.push(this.adj[v][i]);
      }
    }
    // console.log(queue)
  }
}
```

```javascript
/**
 *
 * 最短路径中用于显示到达指定顶点的路径
 * @param {*} s 起点
 * @param {*} v 终点
 */
function pathTo(s, v) {
  if (!this.mask[v]) {
    //顶点不可达
    return undefined;
  }

  let path = [];
  for (let i = v; i != s; i = this.edgeTo[i]) {
    path.push(i);
  }
  path.push(s);
  return path;
}
```

理解：在上面的代码中，使用广度优先搜索来获得最短路径，在目标节点被标记时获得路径即最点路径（广度优先搜索的层次性）

## 拓扑排序

> 拓扑排序和深度优先搜索类似。不同的是，拓扑排序算法不会立即输出已访问的顶点，而是访问当前顶点邻接表中的所有相邻顶点，直到这个列表穷尽，才会将当前节点压入栈中

修改 Graph 类

```javascript
// 将各个顶点关联到一个符号
this.vertextList = [];
```

```javascript

```
